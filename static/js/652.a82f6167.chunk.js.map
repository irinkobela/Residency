{"version":3,"file":"static/js/652.a82f6167.chunk.js","mappings":"2KAIA,MAAMA,EAAeC,IAOd,IAADC,EAAA,IAPgB,SACpBC,EAAQ,eACRC,EAAc,gBACdC,EAAe,kBACfC,EAAiB,wBACjBC,EAAuB,iBACvBC,GACDP,EACC,MAAOQ,EAAgBC,IAAqBC,EAAAA,EAAAA,UAAS,OAC9CC,EAAYC,IAAiBF,EAAAA,EAAAA,UAASH,IAAoB,GAC3DM,GAAiBC,EAAAA,EAAAA,QAAO,MACxBC,GAAcD,EAAAA,EAAAA,QAAO,OAE3BE,EAAAA,EAAAA,WAAU,KAERP,EAAkB,MAClBG,EAAcL,IAAoB,GAG9BQ,EAAYE,SACdF,EAAYE,QAAQC,eAAe,CACjCC,SAAU,SACVC,MAAO,WAGV,CAAClB,EAAUK,KAEdS,EAAAA,EAAAA,WAAU,MAGcZ,GAAoBO,GAAcL,IAA6BO,EAAeI,SAElGJ,EAAeI,QAAQC,eAAe,CACpCC,SAAU,SACVC,MAAO,WAGV,CAAChB,EAAiBO,EAAYL,IAEjC,MAmBMe,EAAsBC,IAE1B,GAAIX,EAAY,CACd,GAAIW,EAAOC,UACT,MAAO,wBAGT,GAAIf,IAAmBc,IAAWA,EAAOC,UACvC,MAAO,yBAIX,CACA,MAAO,iBAIHC,EAA2D,QAA1CvB,EAAGC,EAASuB,QAAQC,KAAKC,GAAKA,EAAEJ,kBAAU,IAAAtB,OAAA,EAAvCA,EAAyC2B,KAG7DC,EAA6BlB,GAAcJ,EAEjD,OAEEuB,EAAAA,EAAAA,MAAA,OAAKC,UAAU,gBAAgBC,IAAKjB,EAAYkB,SAAA,EAC9CH,EAAAA,EAAAA,MAAA,MAAIC,UAAU,gBAAeE,SAAA,CAAC,UAAG/B,EAASA,aAC1CgC,EAAAA,EAAAA,KAAA,OAAKH,UAAU,oBAAmBE,SAC/B/B,EAASuB,QAAQU,IAAI,CAACb,EAAQc,KAC7BF,EAAAA,EAAAA,KAAA,UAEEH,UAAWV,EAAmBC,GAC9Be,QAASA,IAlDQf,KAErBX,IACJF,EAAkBa,GAClBV,GAAc,GACVT,GACFA,EAAeD,EAASoC,GAAIhB,EAAOC,aA4CdgB,CAAkBjB,GACjCkB,SAAU7B,EAAYsB,SAErBX,EAAOM,MALHQ,MAUVP,IACCK,EAAAA,EAAAA,KAAA,OAAKH,UAAU,yBAAwBE,UACrCH,EAAAA,EAAAA,MAAA,KAAGC,UAAU,sBAAqBE,SAAA,CAAC,sFAChBC,EAAAA,EAAAA,KAAA,UAAAD,SAAST,SAK/BK,IACCC,EAAAA,EAAAA,MAAA,OAAKC,UAAU,sBAAsBC,IAAKnB,EAAeoB,SAAA,EAErD3B,IAA4BC,IAC5B2B,EAAAA,EAAAA,KAAA,UAAQH,UAAU,qBAAqBM,QA5DhBI,IAC/BA,EAAEC,kBAGGpC,GAA4BC,GAC/BF,KAuD8E4B,SACrE7B,EAAkB,+FAAsB,sFAK3CA,GAAoBO,GAAcL,GAA4BC,KAC9DuB,EAAAA,EAAAA,MAAA,KAAGC,UAAU,mBAAkBE,SAAA,CAAC,gBAAI/B,EAASyC,sBAQzD,GAAeC,EAAAA,EAAAA,MAAK7C,E","sources":["components/QuestionView.js"],"sourcesContent":["// src/components/QuestionView.js\nimport React, { useState, useEffect, memo, useRef } from 'react';\nimport './QuestionView.css';\n\nconst QuestionView = ({\n  question,\n  onAnswerResult,\n  showExplanation,\n  toggleExplanation,\n  alwaysShowCorrectAnswer,\n  isForcedAnswered,\n}) => {\n  const [selectedAnswer, setSelectedAnswer] = useState(null);\n  const [isAnswered, setIsAnswered] = useState(isForcedAnswered || false);\n  const explanationRef = useRef(null);\n  const questionRef = useRef(null); // <--- NEW: Ref for the question card itself\n\n  useEffect(() => {\n    // Reset internal state when question changes OR when isForcedAnswered changes\n    setSelectedAnswer(null);\n    setIsAnswered(isForcedAnswered || false);\n\n    // <--- NEW: Scroll to the top of the question when a new question is loaded\n    if (questionRef.current) {\n      questionRef.current.scrollIntoView({\n        behavior: 'smooth',\n        block: 'start' // Scrolls the top of the element to the top of the viewport\n      });\n    }\n  }, [question, isForcedAnswered]); // Added question to dependencies to trigger on question change\n\n  useEffect(() => {\n    // Explanation visibility logic considering both external showExplanation and internal isAnswered state\n    // AND the new alwaysShowCorrectAnswer (if the component uses it for display)\n    const shouldScroll = (showExplanation || (isAnswered && alwaysShowCorrectAnswer)) && explanationRef.current;\n    if (shouldScroll) {\n      explanationRef.current.scrollIntoView({\n        behavior: 'smooth',\n        block: 'start'\n      });\n    }\n  }, [showExplanation, isAnswered, alwaysShowCorrectAnswer]);\n\n  const handleAnswerClick = (answer) => {\n    // If feedback is already showing (either by user click or by force), prevent re-clicking\n    if (isAnswered) return;\n    setSelectedAnswer(answer);\n    setIsAnswered(true); // Set QuestionView's internal state to answered\n    if (onAnswerResult) {\n      onAnswerResult(question.id, answer.isCorrect); // Pass result up to parent\n    }\n  };\n\n  const handleToggleExplanation = (e) => {\n    e.stopPropagation();\n    // Only allow manual toggle if explanation is not meant to be always shown by default\n    // and if it's not currently forced answered.\n    if (!alwaysShowCorrectAnswer && !isForcedAnswered) {\n      toggleExplanation();\n    }\n  };\n\n  const getButtonClassName = (answer) => {\n    // If the question is in an 'answered' state (either by user click or forced)\n    if (isAnswered) {\n      if (answer.isCorrect) {\n        return \"answer-button correct\"; // Always highlight correct if answered\n      }\n      // If the user picked this specific answer AND it was incorrect\n      if (selectedAnswer === answer && !answer.isCorrect) {\n        return \"answer-button incorrect\";\n      }\n      // If the question is forced answered, but this specific answer wasn't picked (and isn't correct),\n      // it just gets the default style. The correct one is handled above.\n    }\n    return \"answer-button\"; // Default style if not answered or not incorrect\n  };\n\n  // Find the correct answer text for display\n  const correctAnswerText = question.answers.find(a => a.isCorrect)?.text;\n\n  // Determine if explanation sections should be rendered\n  const shouldShowFeedbackSections = isAnswered || isForcedAnswered;\n\n  return (\n    // <--- NEW: Attach the questionRef to the main question-card div\n    <div className=\"question-card\" ref={questionRef}>\n      <h2 className=\"question-text\">‚ùì {question.question}</h2>\n      <div className=\"answers-container\">\n        {question.answers.map((answer, index) => (\n          <button\n            key={index}\n            className={getButtonClassName(answer)}\n            onClick={() => handleAnswerClick(answer)}\n            disabled={isAnswered} // Disable if already answered (internally or forced)\n          >\n            {answer.text}\n          </button>\n        ))}\n      </div>\n\n      {shouldShowFeedbackSections && (\n        <div className=\"correct-answer-section\">\n          <p className=\"correct-answer-text\">\n            ‚úÖ ·É°·É¨·Éù·É†·Éò ·Éû·Éê·É°·É£·ÉÆ·Éò·Éê: <strong>{correctAnswerText}</strong>\n          </p>\n        </div>\n      )}\n\n      {shouldShowFeedbackSections && (\n        <div className=\"explanation-section\" ref={explanationRef}>\n          {/* Only show toggle button if NOT in alwaysShowCorrectAnswer mode AND not forced answered */}\n          {!alwaysShowCorrectAnswer && !isForcedAnswered && (\n            <button className=\"explanation-toggle\" onClick={handleToggleExplanation}>\n              {showExplanation ? 'üôà ·Éê·ÉÆ·É°·Éú·Éò·É° ·Éì·Éê·Éõ·Éê·Éö·Éï·Éê' : 'üìñ ·Éê·ÉÆ·É°·Éú·Éò·É° ·Éú·Éê·ÉÆ·Éï·Éê'}\n            </button>\n          )}\n          {/* Explanation content visibility depends on showExplanation prop passed from parent\n              OR if it's forced answered and alwaysShowCorrectAnswer is true. */}\n          {(showExplanation || (isAnswered && alwaysShowCorrectAnswer) || isForcedAnswered) && (\n            <p className=\"explanation-text\">‚ÑπÔ∏è {question.explanation}</p>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default memo(QuestionView);\n"],"names":["QuestionView","_ref","_question$answers$fin","question","onAnswerResult","showExplanation","toggleExplanation","alwaysShowCorrectAnswer","isForcedAnswered","selectedAnswer","setSelectedAnswer","useState","isAnswered","setIsAnswered","explanationRef","useRef","questionRef","useEffect","current","scrollIntoView","behavior","block","getButtonClassName","answer","isCorrect","correctAnswerText","answers","find","a","text","shouldShowFeedbackSections","_jsxs","className","ref","children","_jsx","map","index","onClick","id","handleAnswerClick","disabled","e","stopPropagation","explanation","memo"],"sourceRoot":""}